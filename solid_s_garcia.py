# -*- coding: utf-8 -*-
"""SOLID.S.Garcia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E8TEH8WQVPAhA0mECEAzEwr-hitU6fuP

S - Single Responsibility (Responsabilidad Única)

    "Un guerrero, una misión."
"""

class Guerrero:
    def __init__(self, nombre, raza):
        self.nombre = nombre
        self.raza = raza

    def atacar(self):
        return f"{self.nombre} lanza un ataque con su arma."

class LibroDeMazarbul:
    def registrar_batalla(self, guerrero):
        print(f"Crónica: {guerrero.nombre} el {guerrero.raza} ha luchado valientemente.")


aragorn = Guerrero("Aragorn", "Dúnadan")
cronista = LibroDeMazarbul()

print(aragorn.atacar())
cronista.registrar_batalla(aragorn)

"""O - Open/Closed (Abierto/Cerrado)

    "Las razas crecen, pero su esencia no cambia." El código debe estar
    abierto a extensiones, pero cerrado a modificaciones si sirve bien.
"""

from abc import ABC, abstractmethod

class Hechizo(ABC):
    @abstractmethod
    def lanzar(self): pass

class FuegoDeAnor(Hechizo):
    def lanzar(self): return "¡No puedes pasar!  (Luz cegadora)"

class VozDeSaruman(Hechizo):
    def lanzar(self): return "Susurros persuasivos que nublan la mente... "

class Mago:
    def usar_magia(self, hechizo: Hechizo):
        print(f"El mago canaliza su vara: {hechizo.lanzar()}")

# Ejecución
gandalf = Mago()
gandalf.usar_magia(FuegoDeAnor())
gandalf.usar_magia(VozDeSaruman())

"""L - Liskov Substitution (Sustitución de Liskov)

    "Si parece un Portador del Anillo, debe actuar como uno."
"""

class PortadorDelAnillo(ABC):
    @abstractmethod
    def usar_anillo(self): pass

class Hobbit(PortadorDelAnillo):
    def usar_anillo(self):
        return "Frodo se vuelve invisible y huye de los Nazgûl."

class SenorOscuro(PortadorDelAnillo):
    def usar_anillo(self):
        return "Sauron recupera todo su poder y domina la Tierra Media."

def activar_anillo(personaje: PortadorDelAnillo):
    print(personaje.usar_anillo())

# Ejecución
activar_anillo(Hobbit())
activar_anillo(SenorOscuro())

"""I - Interface Segregation (Segregación de Interfaz)

    "No obligues a un Ent a usar espuelas."  Es mejor tener muchas
    interfaces pequeñas y específicas que una sola gigante.
    
    ( lo del ent es que el ent es un arbol...
    y pues pa que hacerlo subir a un caballo)
"""

class Jinete(ABC):
    @abstractmethod
    def cabalgar(self): pass

class Sabio(ABC):
    @abstractmethod
    def hablar_entico(self): pass

class CaballeroRohan(Jinete):
    def cabalgar(self): print(" ¡Muerte! ¡Cabalgad hacia Gondor!")

class Bárbol(Sabio):
    def hablar_entico(self): print(" Hoom, hom... No seas apresurado.")

# Ejecución
eomer = CaballeroRohan()
eomer.cabalgar()

ent = Bárbol()
ent.hablar_entico()

"""D - Dependency Inversion (Inversión de Dependencias)

    "Depende de la luz de Eärendil, no de la lámpara que la contiene."
      Debes depender de ideas generales y no de detalles.
"""

class Arma(ABC):
    @abstractmethod
    def hacer_danio(self): pass

class Andúril(Arma):
    def hacer_danio(self): return "Corta como el fuego y brilla con luz blanca."

class DagaDeHielo(Arma):
    def hacer_danio(self): return "Frío gélido que paraliza al enemigo."

class Soldado:
    def __init__(self, nombre, arma: Arma):
        self.nombre = nombre
        self.arma = arma

    def combatir(self):
        print(f"{self.nombre} lucha: {self.arma.hacer_danio()}")


espada_real = Andúril()
rey = Soldado("Aragorn", espada_real)
rey.combatir()

merry = Soldado("Merry", DagaDeHielo())
merry.combatir()

"""S: Single Responsibility Principle

Basicamanente, cada clase se debe encargar de una sola cosa, eso si, tiene que hacerla bien ya que solo esa clase deberia de encargarse de la cosa que se le encarga

O: Open/Closed Principle

No se deberia tener que romber codigo viejo que funciona cada vez que se le pone algo nuevo al codigo ya sea funciones o clases...si el codigo viejo esta mal hecho ahi es otra cosa

L: Liskov Substitution Principle

Si heredas algo no lo danes, que el hijo no sea pendejo

I: Interface Segregation Principle

No sirve de nada que una clase tenga implementados metodos qe no necesita, no hay que forzar por que uno cree que podria llegar a servir, es perdidad de recursos y tiempo

D: Dependency Inversion Principle

Si uno quita todo lo tecnico de por medio...mejor varias clases o interfaces pequenas que hacen cada una una cosa pero bien, a una clase gigantesza con un monton de cosas inutiles que podrian quitarse y ponerse en otras clases



"""

